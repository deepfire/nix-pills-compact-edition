# -*- indent-tabs-mode: nil -*-
#+startup: hidestars odd

* About this document

  [[https://github.com/deepfire/nix-pills-compact-edition/blob/master/Nix-Pills-Compact-Edition.org][Nix Pills Compact Edition]] is an on-going attempt to reformulate the excellent
  series of articles by [[http://lethalman.blogspot.com/][Luca Bruno]], known as [[http://lethalman.blogspot.ru/2014/07/nix-pill-1-why-you-should-give-it-try.html][Nix Pills]], with the following
  differences in mind:

    - a more compact, outline-based format
    - an attempt at a more definition-based approach
    - ..while trying to give a more complete picture

  In some places I have been outright plagiarizing Luca through liberal
  cut'n'paste, as is consistent with the idea of "reformulation", so this is very
  much a derived work, and so, as usual -- all the greatness is due to Luca, all
  the mistakes were added by me.

*** The preferred way to edit this document

    ..is through the excellent Org Mode: http://orgmode.org/ -- a richer, but
    still light-weight, alternative to Markdown.

* Index

  - [[https://github.com/deepfire/nix-pills-compact-edition#nix-pill-1-why-you-should-give-it-a-try][Nix Pill #1: why you should give it a try]]
  - [[https://github.com/deepfire/nix-pills-compact-edition#nix-pill-2-install-on-your-running-system][Nix Pill #2: install on your running system]]
  - [[https://github.com/deepfire/nix-pills-compact-edition#nix-pill-4-the-basics-of-the-language][Nix Pill #4: the basics of the language]]

* Nix Pill #1: why you should give it a try

*** Motivation: problems with other package managers

    - not being purely functional
    - multiple versions are possible, but take a lot of effort
    - changing installation paths means breaking implicit assumptions about the file system hierarchy
    - containers, as a blunt solution, have their serious drawbacks
      - nearly useless without: orchestration, shared package cache
    - per-language sandbox-like solutions: virtualenv, cabal sandbox
      - scope that is too narrow -- compiler, C libraries are not taken into account
      - a bunch of specific solutions with different flaws

*** Nix way: purely functional, universal solution at the right level of abstraction

    - no assumption about the global state of the system
    - system composed of elements (called /derivations/), that are explicitly
      /derived/ from each other
    - global, /hash/-addressed, immutable =/nix/store=, storing /derivation outputs/ -- results of
      building packages from source, where, during build:
      - all gratuitious variables are set to their mathematical equivalent of zero (or /identity/, if you will)
        - time/date
        - environment
        - non-essential file system contents -- the build is chrooted
      - all essential variables (called /build inputs/) count into the /hash/
        of the store elements, and are fixed forever:
        - build toolchain -- compiler / linker / etc.
        - other build time dependencies -- kernel headers, libc, libraries, make, automake, coreutils
        - runtime dependencies
    - ..which means that nearly identical subsets of packages can peacefully
      coexist along each other, with their only difference, for example, being
      the compiler they were built with
      - which means painless, entirely separate upgrades -- at the cost of disc space, of course
    - (indirectly) composing =PATH= from elements stored in =/nix/store=

*** Nix way: immutability

    - Other package managers mutate global state by replacing packages in-place:
      - the library namespace granularity is mostly just the /soname/
      - new library gets used by all the current packages, linking to that
        /soname/, mostly available at a well-known, standard, shared, global location
    - In /Nix/, the namespace granularity for libraries (and other /inputs/, build or runtime)
      is its /hash/:
      - a new version of =glibc= becomes available at a location based on its /hash/,
        which will be known only to the packages that will be newly built with
        that particular /derivation/ as a specific build input -- passed as if
        by a function call
    - Ergo, the /Nix/ equivalent of the traditional glibc "upgrade" is recompiling /everything/!
      - In practice, build farms provide you with the pre-built /derivations/,
        through an opt-out mechanism known as /binary cache/
      - Security updates is a separate story, a story of compromise with the
        principle of purity
    - Another problem is that it's hard to compose at runtime applications
      that don't have in mind a pure functional model, and that can't be
      adapted to:
      - example: Firefox looks for the Flash plugin binary at a global (albeit per-user) path
        - which breaks the /Nix/ model, entirely
        - the solution (known as /wrapping/) is to produce another Firefox
          derivation, that will at runtime feed unmodified Firefox the plugin path
          we desire, allowing us to put the Flash binary into =/nix/store=
    - Yet another question is upgrading data:
      - typically done in-place by other package managers, in best tradition of mutation
      - /Nix/ makes it your own responsibility

*** Conclusion

    - /Nix/ ([[http://nixos.org/nix/manual/][manual]]) maximises both /flexibility/ and /reproducibility/ of system composition
    - /[[http://nixos.org/nixops/][NixOps]]/ (based on /Nix/, /Nixpkgs/ and /NixOS/) makes cloud deployment
      easy, consistent and reliable, effectively deprecating all existing
      containment and orchestration solutions, such as Puppet, Vagrant, you name
      it
    - Weak spots are:
      - dynamic composition at runtime -- solutions exist, but are one-off
      - massive rebuilds due to fundamental component upgrades (kernel, compilers,
        base libraries) -- mostly made irrelevant by build farms
    - However, reality shows that /Nix/ is an eminently livable environment, and
      progress in solving the above problems is being steadily made
    - /[[https://github.com/NixOS/nixpkgs][Nixpkgs]]/ ([[http://nixos.org/nixos/packages.html][search]]) is a completely new repository of all existing software
      - fresh concept
      - growing contribution
      - the current state is far beyond the experimental stage

* Nix Pill #2: install on your running system

*** Origin: http://lethalman.blogspot.ru/2014/07/nix-pill-2-install-on-your-running.html

*** Download

    - /Hydra/, the /Nix/-based CI system, hosts the builds of /Nix/:
      http://hydra.nixos.org/project/nix#tabs-releases
    - The /Nix/ manual contains a [[http://nixos.org/nix/manual/#chap-installation][chapter on installation]]

*** Installation

    - =/nix/store= and a separate user, to isolate the store and build processes:

#+BEGIN_SRC sh
adduser nix
mkdir -m 0755 /nix && chown nix /nix
#+END_SRC

    - From now on, all the operations we do on the shell are done from this =nix=
      user:

#+BEGIN_SRC sh
su - nix
tar -xf nix-1.9-x86_64-linux.tar.bz2
cd nix-1.9-x86_64-linux
./install
#+END_SRC

    *** INCOMPLETE ***

* Nix Pill #3: enter the environment

*** Origin: http://lethalman.blogspot.ru/2014/07/nix-pill-3-enter-environment.html

    *** INCOMPLETE ***

* Nix Pill #4: the basics of the language

*** Introduction

***** Nix-repl

      This chapter makes a heavy use of =nix-repl=.  To install it, issue =nix-env
      -i nix-repl=.

      *CAVEAT*: the =nix-repl= syntax is slightly different than nix syntax when it
      comes to assigning variables.

*** Value types

***** Simple types

      - /integer/
      - /string/
      - /path/
      - /boolean/
      - /null/

***** Complex types

      - /list/
      - /attribute set/
      - /function/ -- yes, a first-class value that can be passed to and
        returned from functions

*** Operators

***** Basic arithmetic:

      - =+=, =-=, =*= and integer division as =builtins.div=:

#+BEGIN_SRC nix
nix-repl> 1+3
4
nix-repl> builtins.div 6 3
2
#+END_SRC

      - *CAVEAT*: =/= is =path= concatenation instead:

        #+BEGIN_SRC nix
        nix-repl> 2/3
        /home/nix/2/3
        #+END_SRC

        - /Nix/ parsed =2/3= as a /relative path/ to the current directory.
        - /Paths/ are parsed as long as there's a slash.
        - Therefore to specify the current directory, use =./=.
        - In addition, /Nix/ also parses urls.
        - Not all /urls/ or /paths/ can be parsed this way.  If a syntax error
          occurs, it's still possible to fallback to plain /strings/.

      - *NOTE*: =builtins.div= is not being used in the whole of /Nixpkgs/
        repository, hence its second-class syntax status.

***** Boolean expressions

      - =||=, =&&=, =!=
      - =!==, *==*
      - less used tests: =<=, =>=, *>=*, *<=*

***** Other operators

      - http://nixos.org/nix/manual/#table-operators

*** Identifiers

    Dash (=-=) is allowed in identifiers:

#+BEGIN_SRC nix
nix-repl> a-b
error: undefined variable `a-b' at (string):1:1
nix-repl> a - b
error: undefined variable `a' at (string):1:1
#+END_SRC

*** Strings

    - String literals :: ..are enclosed by double-quotes ("), or two single-quotes
         (''), with =\=-based escaping:

#+BEGIN_SRC nix
nix-repl> "''foo''"
"''foo''"
nix-repl> ''"foo"''
"\"foo\""
nix-repl> "\"foo\""
"\"foo\""
#+END_SRC

    - /String literal/ syntax provides means for [[http://nixos.org/nix/manual/#ssec-values][interpolation]] of expressions
      within =${...}=:

      #+BEGIN_SRC nix
      nix-repl> foo = "strval"
      nix-repl> "$foo"
      "$foo"
      nix-repl> "${foo}"
      "strval"
      nix-repl> "${2+3}"
      error: cannot coerce an integer to a string, at (string):1:2
      #+END_SRC

      - *NOTE*: ignore the foo = "strval" assignment, it's =nix-repl=-specific syntax.

    - Escaping =${...}= within double-quoted /string literals/ is done with the
      backslash.  Within two single quotes, it's done with =''=:

#+BEGIN_SRC nix
nix-repl> "\${foo}"
"${foo}"
nix-repl> ''test ''${foo} test''
"test ${foo} test"
#+END_SRC

*** Lists

    - List :: an immutable sequence of /expressions/ delimited by space (not comma):

#+BEGIN_SRC nix
nix-repl> [ 2 "foo" true (2+3) ]
[ 2 "foo" true 5 ]
#+END_SRC

    - Adding or removing elements from a list is only possible through production
      of a new list.

*** Attribute sets

    - Attribute set :: a set of associations between /keys/ and /values/, where:
      - /keys/ can be either/identifiers/ or /strings/, for the cases when desired
        key names aren't valid identifiers
      - /values/ can be arbitrary /Nix/ /expressions/

    - Example value:

      #+BEGIN_SRC nix
      nix-repl> s = { foo = "bar"; a-b = "baz"; "123" = "num"; }
      nix-repl> s
      { 123 = "num"; a-b = "baz"; foo = "bar"; }
      #+END_SRC

      - The output from =nix-repl= is wrong, you can't write { 123 = "num"; } because 123 is not an identifier.
      - Semicolon (;) is required after every key-value assignment.
      - For those reading /Nix/ expressions from /Nixpkgs/: do not confuse
        /attribute sets/ (which are /values/) with /argument sets/ used in
        function definitions (which are /argument specifiers/).

    - Accessing elements:

#+BEGIN_SRC nix
nix-repl> s.a-b
"baz"
nix-repl> s."123"
"num"
#+END_SRC

    - Defining /recursive attribute sets/:
      - Exhibit of the problem:

#+BEGIN_SRC nix
nix-repl> { a = 3; b = a+4; }
error: undefined variable `a' at (string):1:10
#+END_SRC

      - Problem statement -- =a= isn't in scope for =b=
      - Solution: *INCOMPLETE*: URL

#+BEGIN_SRC nix
nix-repl> rec { a= 3; b = a+4; }
{ a = 3; b = 7; }
#+END_SRC

*** If expression

#+BEGIN_SRC nix
nix-repl> a = 3
nix-repl> b = 4
nix-repl> if a > b then "yes" else "no"
"no"
#+END_SRC

    - Both =then= and =else= must be available -- so the value of the expression
      is always defined.

*** Let expression

    - Introducing variables into scope:

#+BEGIN_SRC nix
nix-repl> let a = 3; b = 4; in a + b
7
#+END_SRC

    - ..with recursion:

#+BEGIN_SRC nix
nix-repl> let a = 4; b = a + 5; in b
9
#+END_SRC

    - Variable scopes compose..:

#+BEGIN_SRC nix
nix-repl> let a = 3; in let b = 4; in a + b
7
#+END_SRC

    - ..with shadowing:

#+BEGIN_SRC nix
nix-repl> let a = 3; in let a = 8; b = 4; in a + b
12
#+END_SRC

*** With expression

    - =with= allows "opening" /attribute sets/, binding names of its keys to their
      corresponding values:

#+BEGIN_SRC nix
nix-repl> longExpression = { a = 3; b = 4; "123" = 5; }
nix-repl> longExpression.a + longExpression.b
7
nix-repl> with longExpression; a + b
7
#+END_SRC

    - *CAVEAT*: only valid identifiers from the set keys will be included

#+BEGIN_SRC nix
nix-repl> let a = 10; in with longExpression; a + b + longExpression."123"
19
#+END_SRC

    - *CAVEAT*: if an identifier is bound in the outer scope and is also present
      in the attribute set of =with=, it will *not* be shadowed

#+BEGIN_SRC nix
nix-repl> let a = 10; in with longExpression; a + b
14
nix-repl> let a = 10; in with longExpression; longExpression.a + b
7
#+END_SRC

*** Laziness

    /Nix/ evaluates expressions only [[http://en.wikipedia.org/wiki/Lazy_evaluation][when needed]].  This allows easy definition of
    mutually referencing entities and efficient handling of large package
    repository definitions.

    *** INCOMPLETE ***

* Nix Pill #5: functions and imports

*** Origin: http://lethalman.blogspot.ru/2014/07/nix-pill-5-functions-and-imports.html

    *** INCOMPLETE ***

* Nix Pill #6: our first derivation

*** Origin: http://lethalman.blogspot.ru/2014/07/nix-pill-6-our-first-derivation.html

    *** INCOMPLETE ***

* Nix Pill #7: a working derivation

*** Origin: http://lethalman.blogspot.ru/2014/07/nix-pill-7-working-derivation.html

    *** INCOMPLETE ***

* Nix Pill #8: generic builders

*** Origin: http://lethalman.blogspot.ru/2014/08/nix-pill-8-generic-builders.html

    *** INCOMPLETE ***

* Nix Pill #9: automatic runtime dependencies

*** Origin: http://lethalman.blogspot.ru/2014/08/nix-pill-9-automatic-runtime.html

    *** INCOMPLETE ***

* Nix Pill #10: developing with nix-shell

*** Origin: http://lethalman.blogspot.ru/2014/08/nix-pill-10-developing-with-nix-shell.html

    *** INCOMPLETE ***

* Nix Pill #11: the garbage collector

*** Origin: http://lethalman.blogspot.ru/2014/08/nix-pill-11-garbage-collector.html

    *** INCOMPLETE ***

* Nix Pill #12: the inputs design pattern

*** Origin: http://lethalman.blogspot.ru/2014/08/nix-pill-12-inputs-design-pattern.html

    *** INCOMPLETE ***

* Nix Pill #13: the callPackage design pattern

*** Origin: http://lethalman.blogspot.ru/2014/09/nix-pill-13-callpackage-design-pattern.html

    *** INCOMPLETE ***

* Nix Pill #14: the override design pattern

*** Origin: http://lethalman.blogspot.ru/2014/09/nix-pill-14-override-design-pattern.html

    *** INCOMPLETE ***

* Nix Pill #15: nix search paths

*** Origin: http://lethalman.blogspot.ru/2014/09/nix-pill-15-nix-search-paths.html

    *** INCOMPLETE ***

* Nix Pill #16: nixpkgs, the parameters

*** Origin: http://lethalman.blogspot.ru/2014/11/nix-pill-16-nixpkgs-parameters.html

    *** INCOMPLETE ***

* Nix Pill #17: nixpkgs, overriding packages

*** Origin: http://lethalman.blogspot.ru/2014/11/nix-pill-17-nixpkgs-overriding-packages.html

    *** INCOMPLETE ***

* Nix Pill #18: nix store paths

*** Origin: http://lethalman.blogspot.ru/2015/01/nix-pill-18-nix-store-paths.html

    *** INCOMPLETE ***
